(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{610:function(a,e,s){"use strict";s.r(e);var t=s(15),r=Object(t.a)({},(function(){var a=this,e=a.$createElement,s=a._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p",[a._v("https://github.com/suncaiyu/LearnOpenGLCN")]),a._v(" "),s("h1",{attrs:{id:"摄像机-观察空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#摄像机-观察空间"}},[a._v("#")]),a._v(" 摄像机/观察空间")]),a._v(" "),s("p",[a._v("当我们讨论摄像机/观察空间(Camera/View Space)的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。要定义一个摄像机，我们需要它在世界空间中的位置、观察的方向、一个指向它右侧的向量以及一个指向它上方的向量。细心的读者可能已经注意到我们实际上创建了一个三个单位轴相互垂直的、以摄像机的位置为原点的坐标系。\n"),s("img",{attrs:{src:"https://learnopengl-cn.github.io/img/01/09/camera_axes.png",alt:""}})]),a._v(" "),s("h2",{attrs:{id:"_1-摄像机位置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-摄像机位置"}},[a._v("#")]),a._v(" 1. 摄像机位置")]),a._v(" "),s("p",[a._v("获取摄像机位置很简单。摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量。我们把摄像机位置设置为上一节中的那个相同的位置：")]),a._v(" "),s("div",{staticClass:"language-c++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[s("em",[s("strong",[a._v("不要忘记正z轴是从屏幕指向你的，如果我们希望摄像机向后移动，我们就沿着z轴的正方向移动。")])])]),a._v(" "),s("h2",{attrs:{id:"_2-摄像机方向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-摄像机方向"}},[a._v("#")]),a._v(" 2. 摄像机方向")]),a._v(" "),s("p",[a._v("下一个需要的向量是摄像机的方向，这里指的是摄像机指向哪个方向。现在我们让摄像机指向场景原点：(0, 0, 0)。还记得如果将两个矢量相减，我们就能得到这两个矢量的差吗？用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量。由于我们知道摄像机指向z轴负方向，但我们希望方向向量(Direction Vector)指向摄像机的z轴正方向。如果我们交换相减的顺序，我们就会获得一个指向摄像机正z轴方向的向量：")]),a._v(" "),s("div",{staticClass:"language-c++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);\nglm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("p",[s("em",[s("strong",[a._v("方向向量(Direction Vector)并不是最好的名字，因为它实际上指向从它到目标向量的相反方向（译注：注意看前面的那个图，蓝色的方向向量大概指向z轴的正方向，与摄像机实际指向的方向是正好相反的）。")])])]),a._v(" "),s("h2",{attrs:{id:"_3-右轴"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-右轴"}},[a._v("#")]),a._v(" 3. 右轴")]),a._v(" "),s("p",[a._v("我们需要的另一个向量是一个右向量(Right Vector)，它代表摄像机空间的x轴的正方向。为获取右向量我们需要先使用一个小技巧：先定义一个上向量(Up Vector)。接下来把上向量和第二步得到的方向向量进行叉乘。两个向量叉乘的结果会同时垂直于两向量，因此我们会得到指向x轴正方向的那个向量（如果我们交换两个向量叉乘的顺序就会得到相反的指向x轴负方向的向量）：")]),a._v(" "),s("div",{staticClass:"language-c++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f); \nglm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("h2",{attrs:{id:"_4-上轴"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-上轴"}},[a._v("#")]),a._v(" 4. 上轴")]),a._v(" "),s("p",[a._v("现在我们已经有了x轴向量和z轴向量，获取一个指向摄像机的正y轴向量就相对简单了：我们把右向量和方向向量进行叉乘：")]),a._v(" "),s("div",{staticClass:"language-c++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("在叉乘和一些小技巧的帮助下，我们创建了所有构成观察/摄像机空间的向量。对于想学到更多数学原理的读者，提示一下，在线性代数中这个处理叫做格拉姆—施密特正交化(Gram-Schmidt Process)。使用这些摄像机向量我们就可以创建一个LookAt矩阵了，它在创建摄像机的时候非常有用。")]),a._v(" "),s("h1",{attrs:{id:"look-at"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#look-at"}},[a._v("#")]),a._v(" Look At")]),a._v(" "),s("p",[a._v("使用矩阵的好处之一是如果你使用3个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这3个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是LookAt矩阵所做的，现在我们有了3个相互垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建我们自己的LookAt矩阵了：\n$$LookAt = \\begin{bmatrix} \\color{red}{R_x} & \\color{red}{R_y} & \\color{red}{R_z} & 0 \\ \\color{green}{U_x} & \\color{green}{U_y} & \\color{green}{U_z} & 0 \\ \\color{blue}{D_x} & \\color{blue}{D_y} & \\color{blue}{D_z} & 0 \\ 0 & 0 & 0  & 1 \\end{bmatrix} * \\begin{bmatrix} 1 & 0 & 0 & -\\color{purple}{P_x} \\ 0 & 1 & 0 & -\\color{purple}{P_y} \\ 0 & 0 & 1 & -\\color{purple}{P_z} \\ 0 & 0 & 0  & 1 \\end{bmatrix}$$")]),a._v(" "),s("p",[a._v("其中R是右向量，U是上向量，D是方向向量P是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向。把这个LookAt矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。LookAt矩阵就像它的名字表达的那样：它会创建一个看着(Look at)给定目标的观察矩阵。")]),a._v(" "),s("p",[a._v("幸运的是，GLM已经提供了这些支持。我们要做的只是定义一个摄像机位置，一个目标位置和一个表示世界空间中的上向量的向量（我们计算右向量使用的那个上向量）。接着GLM就会创建一个LookAt矩阵，我们可以把它当作我们的观察矩阵：")]),a._v(" "),s("div",{staticClass:"language-c++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("glm::mat4 view;\nview = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), \n           glm::vec3(0.0f, 0.0f, 0.0f), \n           glm::vec3(0.0f, 1.0f, 0.0f));\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("p",[a._v("glm::LookAt函数需要一个位置、目标和上向量。它会创建一个和在上一节使用的一样的观察矩阵。")]),a._v(" "),s("p",[a._v("在讨论用户输入之前，我们先来做些有意思的事，把我们的摄像机在场景中旋转。我们会将摄像机的注视点保持在(0, 0, 0)。")]),a._v(" "),s("p",[a._v("我们需要用到一点三角学的知识来在每一帧创建一个x和z坐标，它会代表圆上的一点，我们将会使用它作为摄像机的位置。通过重新计算x和y坐标，我们会遍历圆上的所有点，这样摄像机就会绕着场景旋转了。我们预先定义这个圆的半径radius，在每次渲染迭代中使用GLFW的glfwGetTime函数重新创建观察矩阵，来扩大这个圆。")]),a._v(" "),s("div",{staticClass:"language-c++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("float radius = 10.0f;\nfloat camX = sin(glfwGetTime()) * radius;\nfloat camZ = cos(glfwGetTime()) * radius;\nglm::mat4 view;\nview = glm::lookAt(glm::vec3(camX, 0.0, camZ), glm::vec3(0.0, 0.0, 0.0), glm::vec3(0.0, 1.0, 0.0));\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])])])}),[],!1,null,null,null);e.default=r.exports}}]);